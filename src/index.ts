import app from './app';
import { config } from './config';
import { pool, connectWithRetry } from './db';
import { initializeDatabase } from './db/migrations/init';
import { addTestCaseColumns } from './db/migrations/003_add_test_case_columns';
import { addBatchColumns } from './db/migrations/004_add_batch_columns';
import { addBatchNameColumn } from './db/migrations/005_add_batch_name_column';
import { addBatchOrderColumn } from './db/migrations/006_add_batch_order_column';
import { addPromptVersionsTable } from './db/migrations/007_add_prompt_versions';
import { addConfigVersionsTable } from './db/migrations/008_add_config_versions';
import { addTestCaseCategoryPriority } from './db/migrations/009_add_test_case_category_priority';
import { addPromptSuggestionsColumn } from './db/migrations/010_add_prompt_suggestions';
import { createTestWorkflowsTable } from './db/migrations/011_create_test_workflows';
import { addTestModeColumn } from './db/migrations/012_add_test_mode_column';
import { updateAlertEmailStructure } from './db/migrations/012_update_alert_email_structure';
import { createMonitoringTables } from './db/migrations/013_create_monitoring_tables';
import { addProviderAgentIdColumn } from './db/migrations/014_add_provider_agent_id';
import { addSlackIntegration } from './db/migrations/015_add_slack_integration';
import { up as addScheduleEndOptions } from './db/migrations/016_add_schedule_end_options';
import { up as createAdminSystem } from './db/migrations/017_create_admin_system';
import { addContextGrowthTracking } from './db/migrations/018_add_context_growth_tracking';
import { up as addToolDecisions } from './db/migrations/019_add_tool_decisions';
import { up as addGoldenTests } from './db/migrations/020_add_golden_tests';
import { up as addInferenceScans } from './db/migrations/021_add_inference_scans';
import { up as addLeakageTests } from './db/migrations/022_add_leakage_tests';
import { addConsistencyTests } from './db/migrations/023_add_consistency_tests';
import { up as addAutoGeneratedLeakage } from './db/migrations/024_add_auto_generated_leakage';
import { up as addPersonaSecurityFields } from './db/migrations/025_add_persona_security_fields';
import { addPollingConfigToMonitoring } from './db/migrations/026_add_polling_config';
import { up as createMonitoredAgents } from './db/migrations/027_create_monitored_agents';
import { addMonitoringFeatureCosts } from './db/migrations/028_add_monitoring_feature_costs';
import { createBookingsTable } from './db/migrations/029_create_bookings';
import { addTestResultColumns } from './db/migrations/add-test-result-columns';
import { createAlertSettingsTable } from './db/migrations/create-alert-settings';
import { createTeamMembersTable } from './db/migrations/create-team-members';
import { ScheduledTestModel } from './models/scheduledTest.model';
import { schedulerService } from './services/scheduler.service';
import { setWebSocketBroadcast } from './routes/webhook.routes';
import { WebSocketServer, WebSocket } from 'ws';
import http from 'http';

const startServer = async () => {
  try {
    // Test database connection with retries (for Neon cold starts)
    const connected = await connectWithRetry(3, 5000);
    if (!connected) {
      throw new Error('Failed to connect to database after multiple retries');
    }

    // Initialize database tables
    await initializeDatabase();
    
    // Run additional migrations (order matters - some depend on earlier ones)
    await addTestCaseColumns();
    await addBatchColumns();
    await addBatchNameColumn();
    await addBatchOrderColumn();
    await addPromptVersionsTable();
    await addConfigVersionsTable();
    await addTestCaseCategoryPriority();
    await addPromptSuggestionsColumn();
    await createTestWorkflowsTable();
    await addTestModeColumn();
    await updateAlertEmailStructure();
    await createMonitoringTables();
    await addProviderAgentIdColumn();
    await addSlackIntegration();
    await addScheduleEndOptions();
    await createAdminSystem();
    await addContextGrowthTracking();
    await addToolDecisions();
    await addGoldenTests();
    await addInferenceScans(pool);
    await addLeakageTests(pool);
    await addConsistencyTests(pool);
    await addAutoGeneratedLeakage(pool);
    await addPersonaSecurityFields();
    await addPollingConfigToMonitoring();
    await createMonitoredAgents();
    await addMonitoringFeatureCosts();
    await createBookingsTable();
    await addTestResultColumns();
    await createAlertSettingsTable();
    await createTeamMembersTable();
    
    // Create scheduled tests table
    await ScheduledTestModel.createTable();

    // Start the scheduler service
    schedulerService.start();

    // Create HTTP server
    const server = http.createServer(app);

    // WebSocket server for real-time monitoring
    const wss = new WebSocketServer({ server, path: '/ws' });
    
    // Store connections by user ID
    const userConnections = new Map<string, Set<WebSocket>>();

    wss.on('connection', (ws, req) => {
      console.log('[WebSocket] New connection');
      
      // Extract user ID from query string or verify token
      const url = new URL(req.url || '', `http://localhost`);
      const userId = url.searchParams.get('userId');
      const token = url.searchParams.get('token');
      
      // Require either userId or token for connection
      if (!userId && !token) {
        console.log('[WebSocket] Connection rejected - no userId or token');
        ws.close(4001, 'Authentication required');
        return;
      }

      const connUserId = userId || 'anonymous';
      
      if (connUserId) {
        if (!userConnections.has(connUserId)) {
          userConnections.set(connUserId, new Set());
        }
        userConnections.get(connUserId)!.add(ws);
        console.log(`[WebSocket] User ${connUserId} connected`);
      }

      ws.on('message', (message) => {
        try {
          const data = JSON.parse(message.toString());
          // Handle ping/pong for keepalive
          if (data.type === 'ping') {
            ws.send(JSON.stringify({ type: 'pong' }));
          }
        } catch (e) {
          // Ignore invalid messages
        }
      });

      ws.on('close', () => {
        if (connUserId) {
          userConnections.get(connUserId)?.delete(ws);
          if (userConnections.get(connUserId)?.size === 0) {
            userConnections.delete(connUserId);
          }
          console.log(`[WebSocket] User ${connUserId} disconnected`);
        }
      });

      ws.on('error', (error) => {
        console.error('[WebSocket] Error:', error);
      });
    });

    // Set broadcast function for webhooks to use
    setWebSocketBroadcast((userId: string, event: string, data: any) => {
      const connections = userConnections.get(userId);
      if (connections) {
        const message = JSON.stringify({ event, data, timestamp: Date.now() });
        connections.forEach((ws) => {
          if (ws.readyState === WebSocket.OPEN) {
            ws.send(message);
          }
        });
        console.log(`[WebSocket] Broadcast to ${connections.size} connections for user ${userId}: ${event}`);
      }
    });

    // Start server
    server.listen(config.port, () => {
      console.log(`ðŸš€ Server running on port ${config.port}`);
      console.log(`ðŸ“ Environment: ${config.env}`);
      console.log(`ðŸ”— API URL: http://localhost:${config.port}/api`);
      console.log(`ðŸ”Œ WebSocket URL: ws://localhost:${config.port}/ws`);
      console.log(`â° Scheduler service started`);
    });
  } catch (error) {
    console.error('âŒ Failed to start server:', error);
    process.exit(1);
  }
};

// Handle uncaught exceptions
process.on('uncaughtException', (error: any) => {
  // Don't crash on Redis/ioredis connection errors
  const errorStr = String(error?.message || error || '');
  const isRedisError = 
    error?.code === 'ECONNREFUSED' ||
    errorStr.includes('ECONNREFUSED') ||
    errorStr.includes('6379') ||
    errorStr.includes('Redis');
  
  if (isRedisError) {
    return; // Don't crash on Redis errors
  }
  
  console.error('Uncaught Exception:', error);
  process.exit(1);
});

// Handle unhandled promise rejections
process.on('unhandledRejection', (reason: any, promise) => {
  // Don't crash on Redis/ioredis connection errors
  const reasonStr = String(reason?.message || reason || '');
  const isRedisError = 
    reason?.code === 'ECONNREFUSED' ||
    reasonStr.includes('ECONNREFUSED') ||
    reasonStr.includes('6379') ||
    reasonStr.includes('Redis');
  
  if (isRedisError) {
    return; // Silently ignore Redis connection retry rejections
  }
  
  console.error('Unhandled Rejection at:', promise, 'reason:', reason);
  process.exit(1);
});

// Graceful shutdown
process.on('SIGTERM', async () => {
  console.log('SIGTERM received. Shutting down gracefully...');
  schedulerService.stop();
  await pool.end();
  process.exit(0);
});

startServer();
